# 25/03/24 - Lucas Xavier de Morais e Cássia
# Funções base para SEP
# SEP II - Engenharia Elétrica (UFSJ)
import numpy as np
from icecream import ic
import configparser

# Construção da matriz admitancia Y completa
def matrizAdmitancia(dbarras, dcircuitos):
    ncirc = len(dbarras)
    matrizY = np.zeros((ncirc,ncirc),dtype=np.complex_)

    # dbarras
    # 'BARRA' : int(l[0]),
    # 'PD(PU)' : float(l[1]),
    # 'QD(PU)' : float(l[2]),
    # 'Bsh(PU)' : float(l[3]),
    # 'TIPO' : l[4],
    # 'Vesp(PU)' : float(l[5]),
    # 'Oesp' : float(l[6]),
    # 'PGesp(PU)': float(l[7]),
    # 'Cus': float(l[8]),
    # 'CGmin(PU)': float(l[9]),
    # 'CGmax(PU)': float(l[10])

    # dcircuitos
    # 'BDE' : int(l[0]),
    # 'BPARA' : int(l[1]),
    # 'NCIR' : int(l[2]),
    # 'RES(PU)' : float(l[3]),
    # 'REAT(PU)' : float(l[4]),
    # 'SUCsh(PU)' : float(l[5]),
    # 'TAP(PU)' : float(l[6]),
    # 'DEF(GRAUS)' : float(l[7]),
    # 'LIG(L)DESL(D)' : l[8],
    # 'CAP(PU)' : float(l[9])

    for c in dcircuitos:
        if c['LIG(L)DESL(D)'] != 'L' : continue
        k = c['BDE'] - 1
        m = c['BPARA'] - 1
        resistencia = c['RES(PU)']
        reatancia = c['REAT(PU)']
        admitancia = 1/(resistencia + (1j*reatancia))
        susceptancia = 1j*c['SUCsh(PU)']/2
        tap = c['TAP(PU)']
        defasagem = c['DEF(GRAUS)']*np.pi/180
        if k == m :
            matrizY[k][k] = matrizY[k][k] + admitancia
            continue
        matrizY[k][k] = matrizY[k][k] + (tap**2)*admitancia + susceptancia
        matrizY[k][m] = matrizY[k][m] - tap*np.exp(-1j*defasagem)*admitancia
        matrizY[m][k] = matrizY[m][k] - tap*np.exp(1j*defasagem)*admitancia
        matrizY[m][m] = matrizY[m][m] + admitancia + susceptancia

    for b in dbarras:
        k = b['BARRA'] - 1
        if (b['Bsh(PU)'] != 0) : matrizY[k][k] += 1j*b['Bsh(PU)']

    return matrizY

# Funcao para o calculo de potencias (Pcalc) a cada iteração
def calcularFluxoKM(matrizY, angulos, tensoes):
    G = np.copy(matrizY.real)
    B = np.copy(matrizY.imag)
    ativasKCalculada = np.zeros(np.shape(angulos))
    reativasKCalculada = np.zeros(np.shape(angulos))

    for k in range(len(tensoes)):
        for m in range(len(tensoes)):
            Gkm = G[k][m]
            Bkm = B[k][m]
            angulokm = angulos[k] - angulos[m]
            tensaokm = tensoes[k]*tensoes[m]
            cosThetakm = np.cos(angulokm)
            sinThetakm = np.sin(angulokm)

            ativasKCalculada[k] += tensaokm * ( (Gkm * cosThetakm) + (Bkm * sinThetakm) )
            reativasKCalculada[k] += tensaokm * ( (Gkm * sinThetakm) - (Bkm * cosThetakm) )

            # ativasKCalculada[k] += tensoes[m] * ( (Gkm * cosThetakm) + (Bkm * sinThetakm) )
            # reativasKCalculada[k] += tensoes[m] * ( (Gkm * sinThetakm) - (Bkm * cosThetakm) )
        # ativasKCalculada[k] *= tensoes[k]
        # reativasKCalculada[k] *= tensoes[k]

    return ativasKCalculada, reativasKCalculada

# Calculo do vetor H (dP/dTheta)
def dPdTheta(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos):
    G = np.copy(matrizY.real)
    B = np.copy(matrizY.imag)

    jacobianoH = np.zeros((nPV+nPQ, nPV+nPQ))

    for linha in range(nPV+nPQ):
        # Indice atual é o indice do angulo - 1 para poder iterar sorbe a array
        k = indicesAngulos[linha] - 1
        for coluna in range(nPV+nPQ):
            m = indicesAngulos[coluna] - 1
            Gkm = G[k][m]
            Bkm = B[k][m]
            angulokm = angulos[k] - angulos[m]
            tensaokm = tensoes[k]*tensoes[m]
            cosThetakm = np.cos(angulokm)
            sinThetakm = np.sin(angulokm)

            # Verificando se está iterando sobre a diagonal onde o calculo é diferente
            if (k != m):
                jacobianoH[linha][coluna] = tensaokm * ( (Gkm * sinThetakm) - (Bkm * cosThetakm) )
                continue
            jacobianoH[linha][coluna] = -1*(tensaokm**2)*Bkm
            for mAux in range(len(angulos)):
                GkmAux = G[k][mAux]
                BkmAux = B[k][mAux]
                angulokmAux = angulos[k] - angulos[mAux]
                tensaokmAux = tensoes[k]*tensoes[mAux]
                cosThetakmAux = np.cos(angulokmAux)
                sinThetakmAux = np.sin(angulokmAux)

                jacobianoH[linha][coluna] -= tensaokmAux * ( (GkmAux * sinThetakmAux) - (BkmAux * cosThetakmAux) )

    return jacobianoH

# Calculo do vetor N (dP/dV)
def dPdV(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos, indicesTensoes):
    G = np.copy(matrizY.real)
    B = np.copy(matrizY.imag)

    jacobianoN = np.zeros((nPV+nPQ, nPQ    ))

    for linha in range(nPV+nPQ):
        # Indice atual é o indice do angulo - 1 para poder iterar sorbe a array
        k = indicesAngulos[linha] - 1
        for coluna in range(nPQ):
            m = indicesTensoes[coluna] - 1
            Gkm = G[k][m]
            Bkm = B[k][m]
            angulokm = angulos[k] - angulos[m]
            cosThetakm = np.cos(angulokm)
            sinThetakm = np.sin(angulokm)

            # Verificando se está iterando sobre a diagonal onde o calculo é diferente
            if (k != m):
                jacobianoN[linha][coluna] = tensoes[k] * ( (Gkm * cosThetakm) + (Bkm * sinThetakm) )
                continue
            jacobianoN[linha][coluna] = tensoes[k]*Gkm
            for mAux in range(len(angulos)):
                GkmAux = G[k][mAux]
                BkmAux = B[k][mAux]
                angulokmAux = angulos[k] - angulos[mAux]
                cosThetakmAux = np.cos(angulokmAux)
                sinThetakmAux = np.sin(angulokmAux)

                jacobianoN[linha][coluna] += tensoes[mAux] * ( (GkmAux * cosThetakmAux) + (BkmAux * sinThetakmAux) )

    return jacobianoN

# Calculo do vetor M (dQ/dTheta)
def dQdTheta(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos, indicesTensoes):
    G = np.copy(matrizY.real)
    B = np.copy(matrizY.imag)

    jacobianoM = np.zeros((    nPQ, nPV+nPQ))

    for linha in range(nPQ):
        # Indice atual é o indice do angulo - 1 para poder iterar sorbe a array
        k = indicesTensoes[linha] - 1
        for coluna in range(nPV+nPQ):
            m = indicesAngulos[coluna] - 1
            Gkm = G[k][m]
            Bkm = B[k][m]
            angulokm = angulos[k] - angulos[m]
            tensaokm = tensoes[k]*tensoes[m]
            cosThetakm = np.cos(angulokm)
            sinThetakm = np.sin(angulokm)

            # Verificando se está iterando sobre a diagonal onde o calculo é diferente
            if (k != m):
                jacobianoM[linha][coluna] = (-1*tensaokm) * ( (Gkm * cosThetakm) + (Bkm * sinThetakm) )
                continue
            jacobianoM[linha][coluna] = -1*(tensoes[k]**2)*Gkm
            for mAux in range(len(angulos)):
                GkmAux = G[k][mAux]
                BkmAux = B[k][mAux]
                angulokmAux = angulos[k] - angulos[mAux]
                tensaokmAux = tensoes[k]*tensoes[mAux]
                cosThetakmAux = np.cos(angulokmAux)
                sinThetakmAux = np.sin(angulokmAux)

                jacobianoM[linha][coluna] += tensaokmAux * ( (GkmAux * cosThetakmAux) + (BkmAux * sinThetakmAux) )

    return jacobianoM

# Calculo do vetor L (dQ/dV)
def dQdV(matrizY, angulos, tensoes, nPV, nPQ, indicesTensoes):
    G = np.copy(matrizY.real)
    B = np.copy(matrizY.imag)

    jacobianoL = np.zeros((    nPQ,     nPQ))

    for linha in range(nPQ):
        # Indice atual é o indice do angulo - 1 para poder iterar sorbe a array
        k = indicesTensoes[linha] - 1
        for coluna in range(nPQ):
            m = indicesTensoes[coluna] - 1
            Gkm = G[k][m]
            Bkm = B[k][m]
            angulokm = angulos[k] - angulos[m]
            cosThetakm = np.cos(angulokm)
            sinThetakm = np.sin(angulokm)

            # Verificando se está iterando sobre a diagonal onde o calculo é diferente
            if (k != m):
                jacobianoL[linha][coluna] = tensoes[k] * ( (Gkm * sinThetakm) - (Bkm * cosThetakm) )
                continue
            jacobianoL[linha][coluna] = -1*tensoes[k]*Bkm
            for mAux in range(len(angulos)):
                GkmAux = G[k][mAux]
                BkmAux = B[k][mAux]
                angulokmAux = angulos[k] - angulos[mAux]
                cosThetakmAux = np.cos(angulokmAux)
                sinThetakmAux = np.sin(angulokmAux)

                jacobianoL[linha][coluna] += tensoes[mAux] * ( (GkmAux * sinThetakmAux) - (BkmAux * cosThetakmAux) )

    return jacobianoL

def jacobian(matrizY, dbarras, dcircuitos):

    # Montando a matriz H da Jacobiana
    jacH = []
    for k=1:nbus

        total = 0;

        for m = 1:nbus

            H(k,m) = DBAR(k,6)*DBAR(m,6)*(G(k,m)*sin(DBAR(k,7)-DBAR(m,7))- B(k,m)*cos(DBAR(k,7)-DBAR(m,7)));
            soma = DBAR(m,6)*(G(k,m)*sin(DBAR(k,7)-DBAR(m,7))- B(k,m)*cos(DBAR(k,7)-DBAR(m,7)));
            total = soma + total;

        end

        H(k,k) = -DBAR(k,6)^2*B(k,k)- DBAR(k,6)*total;

    end
    return 0 


def calcularAngulosTensoes(matrizY, dbarras):

    # Obtendo parâmetros 
    config = configparser.ConfigParser()
    config.read('config.ini')

    #Construcao dos vetores de angulos e tensoes do sistema
    nbarras = len(dbarras)
    angulos = np.zeros((nbarras,1))
    tensoes = np.ones((nbarras,1))
    c = 0
    for barra in dbarras:
        if (barra['TIPO'] == 'PV' or barra['TIPO'] == 'SW') : tensoes[c] = barra['Vesp(PU)']
        c += 1

    # Definindo o número de barras PV e PQ
    nPV = 0
    nPQ = 0
    for barra in dbarras:
        if barra['TIPO'] == 'PV': nPV += 1
        if barra['TIPO'] == 'PQ': nPQ += 1

    # Montando vetores para armazenar os indices das incognitas do problema
    size = nPV + 2*nPQ
    indices = np.zeros((size,1))
    a = 0 # indice do angulo
    t = nPV+nPQ # indice da tensao
    for barra in dbarras:
        if barra['TIPO'] == 'PV':
            indices[a] = int(barra['BARRA'])
            a += 1
        if barra['TIPO'] == 'PQ':
            indices[a] = int(barra['BARRA'])
            indices[t] = int(barra['BARRA'])
            a += 1
            t += 1
    # Para facilitar o código, separando os vetores em 2, um para os indices dos angulos e outro para os indices das tensoes
    indicesAngulos = []
    indicesTensoes = []
    c = 0
    for i in indices:
        if (c < (nPV+nPQ)): indicesAngulos.append(int(i[0]))
        if (c >= (nPV+nPQ)): indicesTensoes.append(int(i[0]))
        c += 1

    # Calcular as potencias esperadas e agrupá-las em dois vetores, um para
    # potencias ativas e outro para potencias reativas
    ativaEsp = np.zeros((nbarras,1))
    reativaEsp = np.zeros((nbarras,1))
    for barra in dbarras:
        k = barra['BARRA'] - 1
        ativaEsp[k] = barra['PGesp(PU)'] - barra['PD(PU)']
        reativaEsp[k] = - barra['QD(PU)']
    # ativaEsp, reativaEsp = calcularFluxoKM(matrizY, angulos, tensoes)

    # Definindo parâmetros iniciais do método de newton
    maxIter = int(config['NEWTON']['maxIter'])
    tol = float(config['NEWTON']['tolerancia'])
    desacoplado = int(config['NEWTON']['desacoplado'])
    iter = 1
    fimP = 0
    fimQ = 0

    while iter <= maxIter :
        # Calculando pcalc para valores iniciais
        ativasKCalculada, reativasKCalculada = calcularFluxoKM(matrizY, angulos, tensoes)

        #Calculando deltaP e deltaQ
        deltaPks = np.zeros((nPV+nPQ,1))
        deltaQks = np.zeros((nPQ,1))
        c = 0
        for i in indicesAngulos:
            deltaPks[c] = ativaEsp[i-1] - ativasKCalculada[i-1]
            c += 1
        c = 0
        for i in indicesTensoes:
            deltaQks[c] = reativaEsp[i-1] - reativasKCalculada[i-1]
            c += 1

        # Testando convergência
        if np.max(np.abs(deltaPks)) < tol: fimP = 1
        if np.max(np.abs(deltaQks)) < tol: fimQ = 1
        if fimP and fimQ: print('Convergiu em ', iter, ' iterações'); break

        # Montando um vetor com as variações de potência
        deltaPotencias = np.concatenate((deltaPks, deltaQks), axis=0)

        # matriz jacobiano montando primeiro as componentes H, N, M e L
        #Primeiro são feitas as componentes H, N, M e L
    
        jacobianoH = np.copy(dPdTheta(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos))
        jacobianoL = np.copy(dQdV(matrizY, angulos, tensoes, nPV, nPQ, indicesTensoes))

        if desacoplado == 1:
            jacobianoN = np.zeros((nPV+nPQ, nPQ    ))
            jacobianoM = np.zeros((    nPQ, nPV+nPQ))
        else:
            jacobianoN = np.copy(dPdV(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos, indicesTensoes))
            jacobianoM = np.copy(dQdTheta(matrizY, angulos, tensoes, nPV, nPQ, indicesAngulos, indicesTensoes))

        #Essas 2 linhas são para juntar as matrizes H, N e M, L, respectivamente
        jacobianoAuxP = np.concatenate((jacobianoH, jacobianoN), axis=1)
        jacobianoAuxQ = np.concatenate((jacobianoM, jacobianoL), axis=1)

        #Finalmente, juntar todas as matrizes para finalizar o jacobiano
        jacobiano = np.concatenate((jacobianoAuxP, jacobianoAuxQ), axis=0)

        # Fazendo dx = -J^(-1) * g
        invJac = np.linalg.inv(jacobiano)
        deltaX = np.dot(invJac, deltaPotencias)
        print('J')
        print(jacobiano)
        print(jacobiano.shape)
        print('J-1')
        print(invJac)
        print('dx')
        print(deltaX)

        # Imprimindo progresso
        print(iter, maxIter)

        # Atualizando os angulos e tensoes
        c = 0
        for a in indicesAngulos:
            angulos[a-1][0] += deltaX[c][0]
            c += 1
        for t in indicesTensoes:
            tensoes[t-1][0] += deltaX[c][0]
            c += 1

        iter += 1
        ic(angulos, tensoes)
        break

    if iter >= maxIter: print("Nao convergiu")

    angulos = [a[0] for a in angulos]
    tensoes = [t[0] for t in tensoes]
    return angulos, tensoes

def calcularFluxoBarras(matrizY, angulos, tensoes, dcircuitos):

    fluxos = np.zeros((len(angulos), 4))

    c = 0
    for linha in infoLinhas:
        k = int(linha[0]) - 1
        m = int(linha[1]) - 1
        gkm = (linha[2]) / (linha[2]**2 + linha[3]**2)
        bkm = (linha[3]) / (linha[2]**2 + linha[3]**2)
        bshunt = linha[4]/2
        tap = linha[5]
        defasagem = linha[6]*np.pi/180
        Vk = tensoes[k][0]
        Vm = tensoes[m][0]
        tapkmVk = tap * Vk
        thetakm = angulos[k][0] - angulos[m][0]
        fluxos[c][0] = k + 1
        fluxos[c][1] = m + 1
        fluxos[c][2] = (((tapkmVk)**2)*gkm) - (tapkmVk*Vm*gkm*np.cos(thetakm + defasagem)) - (tapkmVk*Vm*bkm*np.sin(thetakm + defasagem))
        fluxos[c][3] = (-((tapkmVk)**2)*(bkm + bshunt)) + (tapkmVk*Vm*bkm*np.cos(thetakm + defasagem)) - (tapkmVk*Vm*gkm*np.sin(thetakm + defasagem))
        c += 1

    return fluxos









